---
title: 指数中高频行情预测和可靠性评估
date: 2022-08-18 08:00:00
tags: 
    - 深度学习
    - 量化交易
    - 行情预测
categories:
    - 量化
---

> 国内主要指数(上证50、沪深300、中证500、中证1000)均有相应的期货/期权衍生品交易品种，为高频日内交易提供了可能。本文探索利用机器学习技术预测中短期行情(10分钟以内)走势的可能性，并在验证集上评估预测效果。总体来看，短期预测的结果与真实情况具有较强的相关性，在进一步加工处理后，可作为策略信号指导期货/期权交易。

## 一、数据
数据分为两类，一类是行情数据，另一类是标签数据，本节介绍这两类数据的一个基本处理情况。

### 1.1 行情数据处理
行情数据又可分为日内行情和日间行情，以及A股和美股市场，根据不同粒度抽取不同的特征。

#### 1.1.1 市场
- A股市场
  - 主要指数:上证50、沪深300、中证500、中证1000
  - 成分股:沪深300+中证500+中证1000，共1800支股票
  - ETF: 主要行业ETF以及宽基ETF
- 美国市场：
  - 成分股: 标普500大盘股+标普400中盘股+ARK基金成分股+主流中概股，约1200只股票
  - ETF: 主要行业ETF以及宽基ETF

#### 1.1.2 日内和日间技术特征提取
主要使用pandas-ta提取RSI、KDJ、Willr等技术因子，以及日内涨跌速度、涨跌幅等统计因子。相关实现见文后往期文章。

#### 1.1.3 日间财务特征提取
目前使用[财务数据-估值有关指标](https://www.ricequant.com/doc/rqdata/python/fundamentals-dictionary.html#%E4%BC%B0%E5%80%BC%E6%9C%89%E5%85%B3%E6%8C%87%E6%A0%87)，进行必要的放缩处理后供机器学习模型使用。

一个小技巧是，使用log变换可将数据有效平滑，例如下面的市盈率因子：
```python
df['pe_ratio_lyr_clip'] = (np.sign(df['pe_ratio_lyr']) * np.log1p(df['pe_ratio_lyr'].abs()) / 10).clip(-3, 3)
```

#### 1.1.4 数据存储
这里将行情数据进行上述加工后，存储到数据库clickhouse中，需要注意的是，使用默认的Float32格式存储，会消耗相当大的空间，尤其是分钟级的日内因子特征。因此，这里处理的技巧是将数据放缩到Short类型(-2^15 ~ 2^15 -1)，使用Int16类型节省一半空间。

### 1.2 标签数据处理
为了同时预测上证50、沪深300、中证500、中证1000在3分钟、5分钟、10分钟内1/4分位、2/4分位、3/4分位的平均收益，我们需要生成36个标签。

由于使用未来的数据进行统计，因此对每只股票、每天的日内情况，先逆序，然后移动一位排除自身，最后通过rolling滑窗的方式统计区间内的四分为值(1/4、2/4、3/4)，最后再逆序回来：
```python
data['pct_rolling_3_25'] = ((data_grouped['minute_avg'].transform(lambda row: row[::-1].shift(1).rolling(3, min_periods=1).quantile(0.25)[::-1]) - data['minute_avg']).div(data['minute_avg']) * 100000).clip(-2**15, 2**15-1).round()
```


## 二、模型

基于上述数据，我们构建一个多标签的深度回归模型，将日内技术特征、时间特征、国内市场日间特征、美国市场日间特征、国内市场股票估值特征等因子联合建模，希望学到他们之间复杂的关系。主体的代码框架如下，其中`TickerEncoder`是一个Embedding模块，负责将所有涉及到的股票ticker编码然后映射成一个向量，`TimeEncoder`负责将时间编码成一个向量，`FeatureEncoder`则将输入的特征数据进行加工后进行池化降维，然后统一拼接到一起，通过分类器预测出36个类别。

```python
class DeepPredictor(nn.Module):
    def __init__(self, ticker_dim=16, depth=1, output_dim=32, class_num=36):
        super(DeepPredictor, self).__init__()
        self.ticker_encoder = TickerEncoder(dim=ticker_dim)
        self.time_encoder = TimeEncoder(dim=4, out_dim=output_dim)
        self.intraday_tech_encoder = FeatureEncoder(self.ticker_encoder, tech_dim=18, ticker_dim=ticker_dim, output_dim=output_dim, depth=depth)
        self.daily_tech_cn_encoder = FeatureEncoder(self.ticker_encoder, tech_dim=23, ticker_dim=ticker_dim, output_dim=output_dim, depth=depth)
        self.daily_tech_us_encoder = FeatureEncoder(self.ticker_encoder, tech_dim=23, ticker_dim=ticker_dim, output_dim=output_dim, depth=depth)
        self.daily_fin_cn_encoder = FeatureEncoder(self.ticker_encoder, tech_dim=23, ticker_dim=ticker_dim, output_dim=output_dim, depth=depth)
        self.pooling = nn.AdaptiveAvgPool1d(1)
        self.pooling2 = nn.AdaptiveMaxPool1d(1)
        self.classifier = nn.Linear(in_features=output_dim * 6, out_features=class_num)
    def forward(self, timestamp, intraday_tech_fea, intraday_tech_ticker, daily_tech_fea_cn, daily_tech_ticker_cn, daily_fin_fea_cn, daily_fin_ticker_cn, daily_tech_fea_us, daily_tech_ticker_us):
        time_out = self.time_encoder(timestamp.squeeze(0)) # seq_len * dim
        intraday_tech_out = self.intraday_tech_encoder(intraday_tech_fea.squeeze(0), intraday_tech_ticker.squeeze(0)) # seq_len * ticker_len * dim
        intraday_tech_out1 = self.pooling(intraday_tech_out.transpose(1, 2)).squeeze(2) # seq_len * dim
        intraday_tech_out2 = self.pooling2(intraday_tech_out.transpose(1, 2)).squeeze(2) # seq_len * dim
        seq_len = intraday_tech_out.shape[0]

        daily_tech_cn_out = self.daily_tech_cn_encoder(daily_tech_fea_cn, daily_tech_ticker_cn) # seq_len * ticker_len * dim
        daily_tech_cn_out = self.pooling(daily_tech_cn_out.transpose(1, 2)).squeeze(2).repeat(seq_len, 1) # seq_len * dim

        daily_fin_cn_out = self.daily_fin_cn_encoder(daily_fin_fea_cn, daily_fin_ticker_cn) # seq_len * ticker_len * dim
        daily_fin_cn_out =  self.pooling(daily_fin_cn_out.transpose(1, 2)).squeeze(2).repeat(seq_len, 1) # seq_len * dim

        daily_tech_us_out = self.daily_tech_us_encoder(daily_tech_fea_us, daily_tech_ticker_us) # seq_len * ticker_len * dim
        daily_tech_us_out =  self.pooling(daily_tech_us_out.transpose(1, 2)).squeeze(2).repeat(seq_len, 1) # seq_len * dim

        feature = torch.cat([time_out, intraday_tech_out1, intraday_tech_out2, daily_tech_cn_out, daily_fin_cn_out, daily_tech_us_out], dim=1) # seq_len * (dim * 6)

        output = self.classifier(feature)  # seq_len * class_num
        return output

```

在训练时，我们将2016-01-05～2022-08-12间的数据进行划分，保留25天的数据作为验证集不参与训练，仅用来评估模型的实际效果。

## 三、评估

### 3.1 相关性评估
计算预测结果和真实结果的皮尔逊相关系数，得到如下结果：
- 整体相关性: 0.4319
- 上证50: 0.3456
- 沪深300: 0.4019
- 中证500: 0.4439
- 中证1000: 0.5015

通常来说，相关系数的分级如下：
- 极强相关: 0.8-1.0 
- 中等程度相关: 0.4-0.6
- 弱相关: 0.2-0.4
- 极弱相关或无相关: 0.0-0.2

因此，从预测难易的程度上看，随着股票规模的增大，预测难度是越来越小的，中证1000指数已经具备中等程度的可预测性！

### 3.2 具体案例分析
我们以2022-08-12日当天，中证1000指数(000852.SH)的预测情况来分析，过滤出预测值大于1(涨幅大于千分之1)的记录，可以发现预测出的涨幅拐点有`2022-08-12 09:33:00`、`2022-08-12 10:14:00 `、`2022-08-12 10:27:00 `、`2022-08-12 10:34:00 `、`2022-08-12 11:16:00 `、`2022-08-12 13:12:00 `、`2022-08-12 13:18:00`、`2022-08-12 13:26:00`、`2022-08-12 13:48:00`、`2022-08-12 14:04:00`约10个，其中正向收益的有7个，因此，预测结果具有一定的利用价值。

| datetime            | metric        |   label |   prediction |
|:--------------------|:--------------|--------:|-------------:|
| 2022-08-12 09:33:00 | rolling_3_75  |    0.64 |       1.0458 |
| 2022-08-12 09:33:00 | rolling_5_75  |    2.14 |       1.2227 |
| 2022-08-12 09:33:00 | rolling_10_75 |    2.1  |       1.4303 |
| 2022-08-12 09:44:00 | rolling_5_75  |    0.4  |       1.1881 |
| 2022-08-12 09:44:00 | rolling_10_75 |    1.02 |       1.3878 |
| 2022-08-12 10:14:00 | rolling_3_75  |    0.53 |       1.0332 |
| 2022-08-12 10:14:00 | rolling_5_75  |    0.48 |       1.1049 |
| 2022-08-12 10:14:00 | rolling_10_75 |    0.24 |       1.204  |
| 2022-08-12 10:27:00 | rolling_3_75  |    0.53 |       1.0847 |
| 2022-08-12 10:27:00 | rolling_5_50  |   -0.01 |       1.0816 |
| 2022-08-12 10:27:00 | rolling_5_75  |    0.5  |       1.198  |
| 2022-08-12 10:27:00 | rolling_10_75 |    1.57 |       1.3889 |
| 2022-08-12 10:34:00 | rolling_3_50  |    1.15 |       1.0736 |
| 2022-08-12 10:34:00 | rolling_3_75  |    1.2  |       1.2097 |
| 2022-08-12 10:34:00 | rolling_5_50  |    0.81 |       1.1209 |
| 2022-08-12 10:34:00 | rolling_5_75  |    1.15 |       1.2745 |
| 2022-08-12 10:34:00 | rolling_10_50 |    0.42 |       1.0476 |
| 2022-08-12 10:34:00 | rolling_10_75 |    0.8  |       1.3831 |
| 2022-08-12 10:35:00 | rolling_5_75  |    0.34 |       1.0499 |
| 2022-08-12 10:35:00 | rolling_10_75 |   -0.1  |       1.1661 |
| 2022-08-12 10:51:00 | rolling_10_75 |    0.36 |       1.1327 |
| 2022-08-12 11:16:00 | rolling_3_75  |    0.45 |       1.0056 |
| 2022-08-12 11:16:00 | rolling_5_75  |    0.45 |       1.1815 |
| 2022-08-12 11:16:00 | rolling_10_75 |    0.41 |       1.363  |
| 2022-08-12 11:17:00 | rolling_10_75 |    0    |       1.055  |
| 2022-08-12 13:12:00 | rolling_5_50  |   -0.68 |       1.0252 |
| 2022-08-12 13:12:00 | rolling_5_75  |   -0.46 |       1.1361 |
| 2022-08-12 13:12:00 | rolling_10_75 |    0.23 |       1.2038 |
| 2022-08-12 13:18:00 | rolling_5_75  |    0.31 |       1.1185 |
| 2022-08-12 13:18:00 | rolling_10_75 |    1.42 |       1.1614 |
| 2022-08-12 13:26:00 | rolling_3_75  |    0.22 |       1.1489 |
| 2022-08-12 13:26:00 | rolling_5_50  |   -0.02 |       1.0274 |
| 2022-08-12 13:26:00 | rolling_5_75  |    0.19 |       1.233  |
| 2022-08-12 13:26:00 | rolling_10_75 |   -0.1  |       1.2839 |
| 2022-08-12 13:33:00 | rolling_10_75 |    0.52 |       1.0791 |
| 2022-08-12 13:48:00 | rolling_3_75  |    0.66 |       1.0106 |
| 2022-08-12 13:48:00 | rolling_5_50  |    0.79 |       1.0117 |
| 2022-08-12 13:48:00 | rolling_5_75  |    0.91 |       1.1305 |
| 2022-08-12 13:48:00 | rolling_10_75 |    0.79 |       1.3026 |
| 2022-08-12 14:04:00 | rolling_3_25  |    1.01 |       1.1566 |
| 2022-08-12 14:04:00 | rolling_3_50  |    1.13 |       1.3214 |
| 2022-08-12 14:04:00 | rolling_3_75  |    1.24 |       1.5201 |
| 2022-08-12 14:04:00 | rolling_5_25  |    0.93 |       1.2081 |
| 2022-08-12 14:04:00 | rolling_5_50  |    1.1  |       1.4657 |
| 2022-08-12 14:04:00 | rolling_5_75  |    1.13 |       1.5158 |
| 2022-08-12 14:04:00 | rolling_10_25 |    0.2  |       1.0725 |
| 2022-08-12 14:04:00 | rolling_10_50 |    0.84 |       1.3458 |
| 2022-08-12 14:04:00 | rolling_10_75 |    1.06 |       1.6887 |
| 2022-08-12 14:05:00 | rolling_10_75 |    0.17 |       1.1434 |

## 四、结论

从预测结果来看，AI模型能够提供指数中高频的短期趋势指导，这为我们进一步优化模型提供了信心来源！在实战上，还需要解决实时性以及信号转化下单工作。大家如有观点看法，欢迎后台留言讨论！

---

#### 推荐阅读

- [利用pandas_ta自动提取技术面特征](https://mp.weixin.qq.com/s/PPduk4xPcix9USW9HmUpHw)
- [跨市场联动:基于美股隔日行情预测A股行业涨跌](https://mp.weixin.qq.com/s/4d6ihxZ7V73iSWUfyaz7tg)

欢迎关注我的公众号“**量化实战**”，原创技术文章第一时间推送。
![](/img/qrcode.jpg)



